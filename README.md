# Документация игрового движка CE1

## Введение

CE1 — это минималистичный однофайловый игровой движок с консольной графикой, написанный на Python. Он прост до предела и не включает сложных концепций, таких как текстуры или полноценные игровые объекты. Основная задача движка — управление буфером символов и их вывод в консоль. Это делает его подходящим для создания текстовых игр или прототипов.

Движок состоит из трёх ключевых компонентов:

- **Screen**: отвечает за отрисовку символов в консоли.
- **Runtime**: управляет основным циклом игры.
- **Values**: содержит настройки движка.

Ниже описаны эти компоненты и их использование.

---

## Класс Values

Класс `Values` содержит основные настройки движка. Экземпляр класса создаётся как глобальная переменная `values`.

### Атрибуты

- **`debug`**: булево значение (`True`/`False`). Включает отладочную информацию, отображаемую как наложение при рендеринге.
- **`tpsLimit`**: целое число. Максимальное количество тиков (итераций цикла) в секунду.
- **`height`**: целое число. Высота экрана в символах.
- **`width`**: целое число. Ширина экрана в символах.
- **`doRender`**: булево значение (`True`/`False`). Указывает, нужно ли рендерить кадры.

---

## Класс Screen

Класс `Screen` управляет графикой движка, используя два буфера символов: один для основного изображения, другой для вывода с наложениями.

### Атрибуты

- **`height`**: высота экрана в символах (берётся из `values.height`).
- **`width`**: ширина экрана в символах (берётся из `values.width`).
- **`frameWithoutOverlays`**: двумерный массив размером `width x height`. Хранит основное изображение без наложений.
- **`frame`**: буфер для вывода в консоль, может включать наложения.

### Методы

1. **`__init__(self)`**  
   Инициализирует буферы экрана, заполняя их символами "#" по умолчанию.

2. **`render(self, overlays=True)`**  
   Выводит содержимое буфера в консоль.
   
   - **Параметр `overlays`**: если `True`, добавляет наложения (например, отладочную информацию).
   - Если `values.doRender = False`, рендеринг не выполняется.

3. **`getPoint(self, x, y)`**  
   Возвращает символ в позиции `(x, y)` из буфера без наложений.
   
   - Если координаты выходят за пределы экрана, возвращает пробел (" ").

4. **`drawPoint(self, x, y, char, isOverlay=False)`**  
   Рисует символ `char` в позиции `(x, y)`.
   
   - **Параметр `isOverlay`**: если `True`, рисует в буфере с наложениями (в коде не реализовано, используется только `frameWithoutOverlays`).
   - Игнорируется, если координаты вне экрана.

5. **`drawLine(self, x1, y1, x2, y2, char, isOverlay=False)`**  
   Рисует линию из символов `char` от `(x1, y1)` до `(x2, y2)` с использованием алгоритма Брезенхэма.
   
   - Ограничивает координаты размерами экрана.

6. **`drawBroken(self, vertices, char, isOverlay=False)`**  
   Рисует ломаную линию по списку вершин `vertices` (формата `[(x1, y1), (x2, y2), ...]`).

7. **`drawPolygon(self, vertices, char, isOverlay=False)`**  
   Рисует замкнутый многоугольник по списку вершин `vertices`.

8. **`drawRectangle(self, x1, y1, x2, y2, char, isFilled=True, isOverlay=False)`**  
   Рисует прямоугольник из символов `char`.
   
   - **Параметр `isFilled`**: если `True`, заполняет внутреннюю область.
   - Ограничивает координаты размерами экрана.

9. **`fill(self, char)`**  
   Заполняет весь буфер символом `char`.
   
   - Принимает только однобуквенные символы.

10. **`printText(self, x, y, text, isOverlay=False)`**  
    Выводит строку `text` начиная с позиции `(x, y)`.
    
    - Обрезает текст, если он выходит за ширину экрана.

11. **`copy(self, x1, y1, x2, y2, targetX, targetY)`**  
    Копирует область из буфера от `(x1, y1)` до `(x2, y2)` в позицию `(targetX, targetY)`.
    
    - **Примечание**: в текущей версии кода метод содержит ошибки (например, некорректные вычисления ширины и высоты).

12. **`addOverlays(self)`**  
    Добавляет отладочную информацию в буфер `frame`, если `values.debug = True`.
    
    - Отображает размер экрана, FPS, TPS и длительность последнего тика.

---

## Класс Runtime

Класс `Runtime` управляет основным циклом игры.

### Атрибуты

- **`tick`**: время между кадрами (вычисляется как `1 / values.tpsLimit`).
- **`run`**: булево значение. Указывает, должен ли цикл продолжаться.

### Методы

1. **`exit(self)`**  
   Устанавливает `run = False`, завершая цикл.

2. **`runtime(self)`**  
   Основной цикл движка:
   
   - Вызывает `start()` один раз в начале.
   - В цикле вызывает `loop()` и `screen.render()`, пока `run = True`.
   - Ограничивает частоту тиков с помощью `sleep()`.
   - После выхода из цикла вызывает `end()`.

3. **`main(self)`**  
   Запускает метод `runtime()`.

---

## Использование движка

Для работы с движком нужно определить три функции:

- **`start()`**: выполняется один раз при запуске для инициализации.
- **`loop()`**: выполняется в каждом кадре для обновления состояния и рисования.
- **`end()`**: выполняется один раз при завершении для финальных действий.

### Пример минимальной программы

```python
def start():
    screen.fill(" ")

def loop():
    screen.fill(" ")
    screen.drawRectangle(0, 0, screen.width-1, screen.height-1, "#", False)
    screen.printText(5, 5, "Привет, CE1!")

def end():
    screen.fill(":")
    screen.printText(5, 5, "Пока!")

runtime.main()
```

Этот код создаёт пустой экран с рамкой и текстом "Привет, CE1!", а при завершении выводит "Пока!".

---

## Наложения

Если `values.debug = True`, при вызове `screen.render(overlays=True)` на экран добавляется отладочная информация:

- Размер окна терминала.
- FPS.
- TPS.
- Длительность последнего тика в секудах.

---

## Ввод данных

Класс `Enter` предоставляет метод для ввода значения от игрока.

### Метод

- **`text(self, ask="", type="str")`**  
  Выводит запрос `ask` и ожидает ввода.
  - **Параметр `type`**:
    - `"str"`: возвращает строку.
    - `"int"`: запрашивает целое число, повторяя запрос при некорректном типе данных.

### Пример

```python
result = enter.text("Введите число:", "int")
```

Выводит "Введите число: " и ожидает ввода числа.

---
